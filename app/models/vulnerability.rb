# frozen_string_literal: true

# Placeholder class for model that is implemented in EE
class Vulnerability < ApplicationRecord
  include IgnorableColumns
  include Gitlab::Utils::StrongMemoize
  include CacheMarkdownField
  include Redactable
  include StripAttribute
  include Noteable
  include Awardable
  include Referable
  include Presentable
  include Gitlab::SQL::Pattern

  cache_markdown_field :title, pipeline: :single_line
  cache_markdown_field :description, issuable_state_filter_enabled: true

  strip_attributes :title

  redact_field :description

  belongs_to :project # keep this association named 'project' for correct work of markdown cache
  belongs_to :milestone
  belongs_to :epic

  belongs_to :author, class_name: 'User' # keep this association named 'author' for correct work of markdown cache
  belongs_to :updated_by, class_name: 'User'
  belongs_to :last_edited_by, class_name: 'User'
  belongs_to :resolved_by, class_name: 'User'
  belongs_to :dismissed_by, class_name: 'User'
  belongs_to :confirmed_by, class_name: 'User'

  has_one :group, through: :project

  # keep the order of the values in the state enum, it is used in state_order method to properly order vulnerabilities based on state
  # remember to recreate index_vulnerabilities_on_state_case_id index when you update or extend this enum
  enum state: { detected: 1, confirmed: 4, resolved: 3, dismissed: 2 }

  validates :project, :author, :title, presence: true

  # at this stage Vulnerability is not an Issuable, has some important attributes (and their constraints) in common
  validates :title, length: { maximum: ::Issuable::TITLE_LENGTH_MAX }
  validates :title_html, length: { maximum: ::Issuable::TITLE_HTML_LENGTH_MAX }, allow_blank: true
  validates :description, length: { maximum: ::Issuable::DESCRIPTION_LENGTH_MAX }, allow_blank: true
  validates :description_html, length: { maximum: ::Issuable::DESCRIPTION_HTML_LENGTH_MAX }, allow_blank: true

  scope :with_author_and_project, -> { includes(:author, :project) }

  scope :visible_to_user_and_access_level, -> (user, access_level) { where(project_id: ::Project.visible_to_user_and_access_level(user, access_level)) }
  scope :for_projects, -> (project_ids) { where(project_id: project_ids) }

  scope :autocomplete_search, -> (query) do
    return self if query.blank?

    id_as_text = Arel::Nodes::NamedFunction.new('CAST', [arel_table[:id].as('TEXT')])

    fuzzy_search(query, [:title])
      .or(where(id_as_text.matches("%#{sanitize_sql_like(query.squish)}%")))
  end

  scope :order_title_asc, -> { reorder(title: :asc, id: :desc) }
  scope :order_title_desc, -> { reorder(title: :desc, id: :desc) }
  scope :order_created_at_asc, -> { reorder(created_at: :asc, id: :desc) }
  scope :order_created_at_desc, -> { reorder(created_at: :desc, id: :desc) }
  scope :order_id_desc, -> { reorder(id: :desc) }

  scope :with_limit, -> (maximum) { limit(maximum) }

  delegate :default_branch, :name, to: :project, prefix: true, allow_nil: true
  delegate :name, to: :group, prefix: true, allow_nil: true

  class << self
    def link_reference_pattern
      nil
    end

    def reference_prefix
      '[vulnerability:'
    end

    def reference_prefix_escaped
      '[vulnerability&lbrack;'
    end

    def reference_postfix
      ']'
    end

    def reference_postfix_escaped
      '&rbrack;'
    end

    def order_by(method)
      case method.to_s
      when 'severity_desc' then order_severity_desc
      when 'severity_asc' then order_severity_asc
      when 'title_desc' then order_title_desc
      when 'title_asc' then order_title_asc
      when 'detected_desc' then order_created_at_desc
      when 'detected_asc' then order_created_at_asc
      when 'report_type_desc' then order_report_type_desc
      when 'report_type_asc' then order_report_type_asc
      when 'state_desc' then order_state_desc
      when 'state_asc' then order_state_asc
      else
        order_severity_desc
      end
    end

    def reference_pattern
      @reference_pattern ||= %r{
        #{Regexp.escape(reference_prefix)}(#{::Project.reference_pattern}\/)?(?<vulnerability>\d+)#{Regexp.escape(reference_postfix)}
      }x
    end

    def link_reference_pattern
      %r{
        (?<url>
          #{Regexp.escape(::Gitlab.config.gitlab.url)}
          \/#{::Project.reference_pattern}
          (?:\/\-)
          \/security\/vulnerabilities
          \/(?<vulnerability>\d+)
          (?<path>
            (\/[a-z0-9_=-]+)*\/*
          )?
          (?<anchor>\#[a-z0-9_-]+)?
        )
      }x
    end

    def parent_class
      ::Project
    end

    def to_ability_name
      model_name.singular
    end
  end

  def to_reference(from = nil, full: false)
    project
      .to_reference_base(from, full: full)
      .then { |reference_base| reference_base.present? ? "#{reference_base}/" : nil }
      .then { |reference_base| "#{self.class.reference_prefix}#{reference_base}#{id}#{self.class.reference_postfix}" }
  end

  # There will only be one finding associated with a vulnerability for the foreseeable future
  def finding
    findings.first
  end

  def resource_parent
    project
  end

  def discussions_rendered_on_frontend?
    true
  end

  def stat_diff
    ::Vulnerabilities::StatDiff.new(self)
  end
end

Vulnerability.prepend_if_ee('EE::Vulnerability')
