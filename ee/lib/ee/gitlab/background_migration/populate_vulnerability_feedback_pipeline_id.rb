# frozen_string_literal: true

module EE
  module Gitlab
    module BackgroundMigration
      # This class creates/updates those project historical vulnerability statistics
      # that haven't been created nor initialized.
      module PopulateVulnerabilityFeedbackPipelineId
        extend ::Gitlab::Utils::Override

        class VulnerabilityFeedback < ActiveRecord::Base
          self.table_name = 'vulnerability_feedback'
        end

        override :perform
        def perform(start_id, stop_id)
          project_ids = VulnerabilityFeedback.where(pipeline_id: nil, id: start_id..stop_id).select(:project_id).distinct.map(&:project_id)

          update_vulnerability_feedback_with_pipeline_id(pipelines_with_security_reports_subquery(project_ids), start_id, stop_id)
          update_vulnerability_feedback_with_pipeline_id(legacy_pipelines_with_security_reports_subquery(project_ids), start_id, stop_id)
        end

        private

        def update_vulnerability_feedback_with_pipeline_id(subquery, start_id, stop_id)
          update_feedback_pipeline_id_sql = <<~SQL
            UPDATE "vulnerability_feedback"
            SET pipeline_id = "pipelines_with_reports"."id"
            FROM (#{subquery}) AS pipelines_with_reports
            WHERE "vulnerability_feedback"."pipeline_id" IS NULL
              AND "vulnerability_feedback"."project_id" = "pipelines_with_reports"."project_id"
              AND "vulnerability_feedback"."created_at" >= "pipelines_with_reports"."finished_at"
              AND "vulnerability_feedback"."id" BETWEEN #{start_id} AND #{stop_id};
          SQL
          connection.execute(update_feedback_pipeline_id_sql)
        rescue => e
          logger.warn(
            message: 'update_vulnerability_feedback_with_pipeline_id errored out',
            start_id: start_id,
            stop_id: stop_id,
            error: e.message
          )
        end

        def pipelines_with_security_reports_subquery(project_ids)
          <<~SQL
            SELECT "ci_pipelines"."id",
              "ci_pipelines"."project_id",
              "ci_pipelines"."finished_at"
            FROM "ci_pipelines"
            WHERE ("ci_pipelines"."project_id" IN (#{project_ids.join(', ')}))
              AND ("ci_pipelines"."status" IN ('success'))
              AND (
                EXISTS (
                  SELECT 1
                  FROM "ci_builds"
                  WHERE "ci_builds"."type" = 'Ci::Build'
                    AND (
                      "ci_builds"."retried" = FALSE
                      OR "ci_builds"."retried" IS NULL
                    )
                    AND (
                      EXISTS (
                        SELECT 1
                        FROM "ci_job_artifacts"
                        WHERE ("ci_builds"."id" = "ci_job_artifacts"."job_id")
                          AND "ci_job_artifacts"."file_type" IN (5, 6, 7, 8, 21, 23, 26)
                      )
                    )
                    AND ("ci_pipelines"."id" = "ci_builds"."commit_id")
                )
              )
            ORDER BY "ci_pipelines"."finished_at" DESC
          SQL
        end

        def legacy_pipelines_with_security_reports_subquery(project_ids)
          <<~SQL
            SELECT "ci_pipelines".*
            FROM "ci_pipelines"
              INNER JOIN "ci_builds" ON "ci_builds"."commit_id" = "ci_pipelines"."id"
                AND "ci_builds"."type" = 'Ci::Build'
                AND ("ci_builds"."retried" = FALSE OR "ci_builds"."retried" IS NULL)
              INNER JOIN "ci_job_artifacts" ON "ci_job_artifacts"."file_type" IN (19, 26, 1, 17, 9, 7, 8, 6, 16, 4, 10, 101, 15, 12, 11, 24, 25, 5, 21, 22)
                AND "ci_job_artifacts"."job_id" = "ci_builds"."id"
            WHERE "ci_pipelines"."project_id" IN (#{project_ids.join(', ')})
              AND ("ci_pipelines"."status" IN ('success'))
              AND "ci_builds"."name" IN ('sast', 'secret_detection', 'dependency_scanning', 'container_scanning', 'dast')
            ORDER BY "ci_pipelines"."finished_at" DESC
          SQL
        end

        def connection
          @connection ||= ActiveRecord::Base.connection
        end

        def logger
          @logger ||= ::Gitlab::BackgroundMigration::Logger.build
        end
      end
    end
  end
end
