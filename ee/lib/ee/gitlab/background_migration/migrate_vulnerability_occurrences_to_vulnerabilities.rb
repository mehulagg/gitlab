# frozen_string_literal: true

module EE
  module Gitlab
    module BackgroundMigration
      # This migration creates vulnerabilities records for vulnerability_occurrences records
      # that exist on the latest successful pipeline of the default branch of a given project
      # and do not already have a vulnerabilities record created.
      # It also updates the states of vulnerabilities records to dismissed if the corresponding
      # vulnerability_occurrences record was dismissed.
      module MigrateVulnerabilityOccurrencesToVulnerabilities
        extend ::Gitlab::Utils::Override
        delegate :select_all, :execute, :quote_string, to: :connection

        VULNERABILITY_DETECTED = 1
        VULNERABILITY_DISMISSED = 2
        VULNERABILITY_FEEDBACK_DISMISSAL = 0

        BATCH_SIZE = 10_000

        class VulnerabilityOccurrencePipeline < ActiveRecord::Base
          self.table_name = 'vulnerability_occurrence_pipelines'

          include ::EachBatch
        end

        override :perform
        def perform(project_id)
          sql = <<-SQL
            SELECT 1 FROM vulnerabilities WHERE vulnerabilities.project_id = #{project_id} LIMIT 1
          SQL

          result = ActiveRecord::Base.connection.execute(sql)
          if result.values.flatten.blank?

            latest_pipeline_sql = <<-SQL
              vulnerability_occurrence_pipelines.pipeline_id = (
                SELECT MAX(id) AS max_id
                FROM ci_pipelines
                WHERE project_id = #{project_id}
                AND status='success'
                AND EXISTS (
                  SELECT 1 FROM vulnerability_occurrence_pipelines
                  WHERE ci_pipelines.id = vulnerability_occurrence_pipelines.pipeline_id
                )
              )
            SQL

            VulnerabilityOccurrencePipeline.select('occurrence_id').where(latest_pipeline_sql).each_batch(of: BATCH_SIZE, column: 'occurrence_id') do |batch, index|
              start_id, end_id = batch.pluck('MIN(occurrence_id), MAX(occurrence_id)').first

              ActiveRecord::Base.transaction do
                create_vulnerability_records(project_id, start_id, end_id)
              end
            end
          end

          update_vulnerability_to_dismissed(project_id)
        end

        private

        def create_vulnerability_records(project_id, start_id, end_id)
          sql = <<-SQL
            WITH last_pipeline AS (
              SELECT MAX(id) AS id FROM ci_pipelines WHERE project_id = #{project_id} AND status='success' AND EXISTS (SELECT 1 FROM vulnerability_occurrence_pipelines WHERE ci_pipelines.id = vulnerability_occurrence_pipelines.pipeline_id)
            )
            INSERT INTO vulnerabilities(project_id, author_id, created_at, updated_at, title, title_html, state, severity, confidence, report_type, vulnerability_occurrence_id)
            SELECT #{project_id}, ci_pipelines.user_id, vulnerability_occurrences.created_at, vulnerability_occurrences.updated_at, left(vulnerability_occurrences.name, 255), vulnerability_occurrences.name, 1, vulnerability_occurrences.severity, vulnerability_occurrences.confidence, vulnerability_occurrences.report_type, vulnerability_occurrences.id
            FROM vulnerability_occurrence_pipelines
            JOIN last_pipeline ON last_pipeline.id = vulnerability_occurrence_pipelines.pipeline_id
            JOIN  vulnerability_occurrences on vulnerability_occurrence_pipelines.occurrence_id = vulnerability_occurrences.id
            JOIN ci_pipelines ON vulnerability_occurrence_pipelines.pipeline_id = ci_pipelines.id
            WHERE vulnerability_occurrences.id >= #{start_id} AND vulnerability_occurrences.id <= #{end_id}
          SQL

          ActiveRecord::Base.connection.execute(sql)

          sql_update = <<-SQL
           update vulnerability_occurrences set vulnerability_id = vulnerabilities.id
           from vulnerabilities
           where vulnerabilities.vulnerability_occurrence_id = vulnerability_occurrences.id
           and vulnerability_occurrences.project_id = #{project_id}
           and vulnerability_occurrences.id >= #{start_id} AND vulnerability_occurrences.id <= #{end_id};
          SQL

          ActiveRecord::Base.connection.execute(sql_update)
        end

        def update_vulnerability_to_dismissed(project_id)
          update_vulnerability_to_dismissed_sql = <<-SQL
            UPDATE vulnerabilities
            SET state = #{VULNERABILITY_DISMISSED}
            FROM vulnerability_occurrences
            WHERE vulnerability_occurrences.vulnerability_id = vulnerabilities.id
              AND vulnerabilities.state = #{VULNERABILITY_DETECTED}
              AND (
                EXISTS (
                  SELECT 1
                  FROM vulnerability_feedback
                  WHERE vulnerability_occurrences.report_type = vulnerability_feedback.category
                    AND vulnerability_occurrences.project_id = vulnerability_feedback.project_id
                    AND ENCODE(vulnerability_occurrences.project_fingerprint, 'HEX') = vulnerability_feedback.project_fingerprint
                    AND vulnerability_feedback.feedback_type = #{VULNERABILITY_FEEDBACK_DISMISSAL}
                )
              )
              AND vulnerability_occurrences.project_id = #{project_id};
          SQL
          execute(update_vulnerability_to_dismissed_sql)
        rescue => e
          logger.warn(
            message: 'update_vulnerability_to_dismissed errored out',
            project_id: project_id,
            error: e.message
          )
        end

        def connection
          @connection ||= ActiveRecord::Base.connection
        end

        def logger
          @logger ||= ::Gitlab::BackgroundMigration::Logger.build
        end
      end
    end
  end
end
