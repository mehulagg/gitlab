# frozen_string_literal: true

module EE
  module Gitlab
    module BackgroundMigration
      # This migration creates vulnerabilities records for vulnerability_occurrences records
      # that exist on the latest successful pipeline of the default branch of a given project
      # and do not already have a vulnerabilities record created.
      # It also updates the states of vulnerabilities records to dismissed if the corresponding
      # vulnerability_occurrences record was dismissed.
      module MigrateVulnerabilityOccurrencesToVulnerabilities
        extend ::Gitlab::Utils::Override
        delegate :execute, to: :connection

        VULNERABILITY_DETECTED = 1
        VULNERABILITY_DISMISSED = 2
        VULNERABILITY_FEEDBACK_DISMISSAL = 0

        BATCH_SIZE = 10_000

        class VulnerabilityOccurrencePipeline < ActiveRecord::Base
          self.table_name = 'vulnerability_occurrence_pipelines'

          include ::EachBatch
        end

        class Vulnerability < ActiveRecord::Base
          self.table_name = 'vulnerabilities'
        end

        class Project < ActiveRecord::Base
          self.table_name = 'projects'
        end

        override :perform
        def perform(project_id)
          project = Project.find_by(id: project_id)

          return unless project
          return if project.archived? || project.pending_delete?

          begin
            if Vulnerability.where(project_id: project.id).empty?
              latest_pipeline = latest_pipeline_sql(project.id)

              VulnerabilityOccurrencePipeline.select('occurrence_id').where(latest_pipeline).each_batch(of: BATCH_SIZE, column: 'occurrence_id') do |batch, index|
                start_id, end_id = batch.pluck('MIN(occurrence_id), MAX(occurrence_id)').first

                ActiveRecord::Base.transaction do
                  create_vulnerability_records(project.id, start_id, end_id)
                end
              end
            end
          rescue => e
            logger.warn(
              message: 'Migration of vulnerabilities errored out',
              project_id: project_id,
              error: e.message
            )
          end

          update_vulnerability_to_dismissed(project.id)
        end

        private

        def latest_pipeline_sql(project_id)
          <<-SQL
            vulnerability_occurrence_pipelines.pipeline_id = (
              SELECT MAX(id) AS max_id
              FROM ci_pipelines
              WHERE project_id = #{project_id}
              AND status='success'
              AND EXISTS (
                SELECT 1 FROM vulnerability_occurrence_pipelines
                WHERE ci_pipelines.id = vulnerability_occurrence_pipelines.pipeline_id
              )
            )
          SQL
        end

        # rubocop:disable Metrics/MethodLength
        def create_vulnerability_records(project_id, start_id, end_id)
          sql = <<-SQL
            WITH last_pipeline AS (
              SELECT
                MAX(id) AS id
              FROM
                ci_pipelines
              WHERE
                project_id = #{project_id}
              AND status='success'
              AND EXISTS (
                SELECT
                  1
                FROM
                  vulnerability_occurrence_pipelines
                 WHERE
                  ci_pipelines.id = vulnerability_occurrence_pipelines.pipeline_id))

            INSERT INTO vulnerabilities(project_id, author_id, created_at, updated_at, title, title_html, state, severity, confidence, report_type, vulnerability_occurrence_id)
            SELECT
              #{project_id},
              ci_pipelines.user_id,
              NOW(),
              NOW(),
              left(vulnerability_occurrences.name, 255),
              vulnerability_occurrences.name,
              #{VULNERABILITY_DETECTED},
              vulnerability_occurrences.severity,
              vulnerability_occurrences.confidence,
              vulnerability_occurrences.report_type,
              vulnerability_occurrences.id
            FROM
              vulnerability_occurrence_pipelines
            JOIN
              last_pipeline
            ON
              last_pipeline.id = vulnerability_occurrence_pipelines.pipeline_id
            JOIN
              vulnerability_occurrences
            ON
              vulnerability_occurrence_pipelines.occurrence_id = vulnerability_occurrences.id
            JOIN
              ci_pipelines
            ON
              vulnerability_occurrence_pipelines.pipeline_id = ci_pipelines.id
            WHERE
              vulnerability_occurrences.id >= #{start_id}
            AND
              vulnerability_occurrences.id <= #{end_id}
          SQL

          execute(sql)

          sql_update = <<-SQL
           UPDATE vulnerability_occurrences SET vulnerability_id = vulnerabilities.id
           FROM vulnerabilities
           WHERE vulnerabilities.vulnerability_occurrence_id = vulnerability_occurrences.id
           AND vulnerability_occurrences.project_id = #{project_id}
           AND vulnerability_occurrences.id >= #{start_id} AND vulnerability_occurrences.id <= #{end_id};
          SQL

          execute(sql_update)
        end
        # rubocop:enable Metrics/MethodLength

        def update_vulnerability_to_dismissed(project_id)
          update_vulnerability_to_dismissed_sql = <<-SQL
            UPDATE vulnerabilities
            SET state = #{VULNERABILITY_DISMISSED}
            FROM vulnerability_occurrences
            WHERE vulnerability_occurrences.vulnerability_id = vulnerabilities.id
              AND vulnerabilities.state = #{VULNERABILITY_DETECTED}
              AND (
                EXISTS (
                  SELECT 1
                  FROM vulnerability_feedback
                  WHERE vulnerability_occurrences.report_type = vulnerability_feedback.category
                    AND vulnerability_occurrences.project_id = vulnerability_feedback.project_id
                    AND ENCODE(vulnerability_occurrences.project_fingerprint, 'HEX') = vulnerability_feedback.project_fingerprint
                    AND vulnerability_feedback.feedback_type = #{VULNERABILITY_FEEDBACK_DISMISSAL}
                )
              )
              AND vulnerability_occurrences.project_id = #{project_id};
          SQL
          execute(update_vulnerability_to_dismissed_sql)
        rescue => e
          logger.warn(
            message: 'update_vulnerability_to_dismissed errored out',
            project_id: project_id,
            error: e.message
          )
        end

        def connection
          @connection ||= ActiveRecord::Base.connection
        end

        def logger
          @logger ||= ::Gitlab::BackgroundMigration::Logger.build
        end
      end
    end
  end
end
