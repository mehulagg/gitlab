# frozen_string_literal: true

module Gitlab
  module Ci
    module Reports
      module Security
        class VulnerabilityReportsComparer
          include Gitlab::Utils::StrongMemoize

          attr_reader :base_report, :head_report

          ACCEPTABLE_REPORT_AGE = 1.week

          def initialize(project, base_report, head_report)
            @base_report = base_report
            @head_report = head_report
            @signatures_enabled = (
              ::Feature.enabled?(:vulnerability_finding_tracking_signatures, project) &&
              project.licensed_feature_available?(:vulnerability_finding_signatures)
            )

            if @signatures_enabled
              @added = []
              @fixed = []
              calculate_changes
            end
          end

          def base_report_created_at
            @base_report.created_at
          end

          def head_report_created_at
            @head_report.created_at
          end

          def base_report_out_of_date
            return false unless @base_report.created_at

            ACCEPTABLE_REPORT_AGE.ago > @base_report.created_at
          end

          def added
            if @signatures_enabled
              return @added
            end

            strong_memoize(:added) do
              head_report.findings - base_report.findings
            end
          end

          def fixed
            if @signatures_enabled
              return @fixed
            end

            strong_memoize(:fixed) do
              base_report.findings - head_report.findings
            end
          end

          def calculate_changes
            # This is a deconstructed version of the eql? method on
            # Ci::Reports::Security::Finding. It:
            #
            # * precomputes for the head_findings:
            #   * sets of signature shas grouped by priority
            #   * mappings of signature shas to the head finding object
            #
            # These are then used when iterating the base findings to perform
            # fast(er) prioritized, signature-based comparisons between each base finding
            # and the head findings.
            #
            # Both the head_findings and base_findings arrays are iterated once

            base_findings = base_report.findings
            head_findings = head_report.findings

            unmatched_head_findings = head_findings.index_by(&:object_id)
            # signature sha -> Finding
            head_signatures_shas = {}
            # { priority -> Set(sha1, sha2, sha3) }
            head_signatures_priorities = Hash.new { |hash, key| hash[key] = Set.new }

            head_findings.each do |head_finding|
              head_finding.signatures.each do |signature|
                head_signatures_priorities[signature.priority].add(signature.signature_sha)
                head_signatures_shas[signature.signature_sha] = head_finding
              end
              # for the final uuid check when no signatures have matched
              head_signatures_shas[head_finding.uuid] = head_finding
            end

            base_findings.each do |base_finding|
              matched_head_finding = nil

              base_finding.signatures.sort_by(&:priority).reverse_each do |signature|
                next unless head_signatures_priorities[signature.priority].include?(signature.signature_sha)

                # at this point a head_finding exists that has a signature with a
                # matching priority, and a matching sha --> lookup the actual finding
                # object from head_signatures_shas
                matched_head_finding = head_signatures_shas[signature.signature_sha]

                # need to do a full eql? comparison here so that the other
                # equality factors are considered (report type, primary identifier type, etc)
                break if matched_head_finding.eql?(base_finding)

                # eql? didn't return true, reset matched_head_finding
                matched_head_finding = nil
              end

              # no signatures matched, so check the normal uuids of the base and head findings
              # for a match
              matched_head_finding = head_signatures_shas[base_finding.uuid] if matched_head_finding.nil?

              if matched_head_finding
                unmatched_head_findings.delete(matched_head_finding.object_id)
              else
                @fixed << base_finding
              end
            end

            @added = unmatched_head_findings.values
          end
        end
      end
    end
  end
end
