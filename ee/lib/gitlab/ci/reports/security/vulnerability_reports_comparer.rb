# frozen_string_literal: true

module Gitlab
  module Ci
    module Reports
      module Security
        class VulnerabilityReportsComparer
          include Gitlab::Utils::StrongMemoize

          attr_reader :base_report, :head_report, :added, :fixed

          ACCEPTABLE_REPORT_AGE = 1.week

          def initialize(base_report, head_report)
            @base_report = base_report
            @head_report = head_report

            @added = []
            @fixed = []
            calculate_changes
          end

          def base_report_created_at
            @base_report.created_at
          end

          def head_report_created_at
            @head_report.created_at
          end

          def base_report_out_of_date
            return false unless @base_report.created_at

            ACCEPTABLE_REPORT_AGE.ago > @base_report.created_at
          end

          def calculate_changes
            base_findings = base_report.findings
            head_findings = head_report.findings

            head_findings_hash = head_findings.index_by(&:object_id)

            # This is slow - O(N^2). If we didn't need to worry about one high
            # priority fingerprint that doesn't match overruling a lower
            # priority fingerprint that does match, we'd be able to do some
            # set operations here
            base_findings.each do |base_finding|
              still_exists = false
              head_findings.each do |head_finding|
                next unless base_finding.eql?(head_finding)

                still_exists = true
                head_findings_hash.delete(head_finding.object_id)
                break
              end

              @fixed << base_finding unless still_exists
            end

            @added = head_findings_hash.values
          end
        end
      end
    end
  end
end
