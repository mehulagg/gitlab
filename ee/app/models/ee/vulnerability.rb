# frozen_string_literal: true

module EE
  module Vulnerability
    extend ActiveSupport::Concern

    prepended do
      include ::Noteable

      TooManyDaysError = Class.new(StandardError)

      MAX_DAYS_OF_HISTORY = 10
      ACTIVE_STATES = %w(detected confirmed).freeze
      PASSIVE_STATES = %w(dismissed resolved).freeze

      has_many :findings, class_name: '::Vulnerabilities::Finding', inverse_of: :vulnerability
      has_many :dismissed_findings, -> { dismissed }, class_name: 'Vulnerabilities::Finding', inverse_of: :vulnerability
      has_many :external_issue_links, class_name: '::Vulnerabilities::ExternalIssueLink', inverse_of: :vulnerability
      has_many :issue_links, class_name: '::Vulnerabilities::IssueLink', inverse_of: :vulnerability
      has_many :created_issue_links, -> { created }, class_name: '::Vulnerabilities::IssueLink', inverse_of: :vulnerability
      has_many :related_issues, through: :issue_links, source: :issue do
        def with_vulnerability_links
          select('issues.*, vulnerability_issue_links.id AS vulnerability_link_id, '\
                'vulnerability_issue_links.link_type AS vulnerability_link_type')
        end
      end

      has_many :notes, as: :noteable, dependent: :delete_all # rubocop:disable Cop/ActiveRecordDependent
      has_many :user_mentions, class_name: 'VulnerabilityUserMention'

      enum severity: ::Vulnerabilities::Finding::SEVERITY_LEVELS, _prefix: :severity
      enum confidence: ::Vulnerabilities::Finding::CONFIDENCE_LEVELS, _prefix: :confidence
      enum report_type: ::Vulnerabilities::Finding::REPORT_TYPES

      validates :severity, :confidence, :report_type, presence: true

      scope :with_findings, -> { includes(:findings) }
      scope :with_findings_and_scanner, -> { includes(findings: :scanner) }
      scope :with_findings_scanner_and_identifiers, -> { includes(findings: [:scanner, :identifiers, finding_identifiers: :identifier]) }
      scope :with_created_issue_links_and_issues, -> { includes(created_issue_links: :issue) }

      scope :with_report_types, -> (report_types) { where(report_type: report_types) }
      scope :with_severities, -> (severities) { where(severity: severities) }
      scope :with_states, -> (states) { where(state: states) }
      scope :with_scanners, -> (scanners) { joins(findings: :scanner).merge(::Vulnerabilities::Scanner.with_external_id(scanners)) }
      scope :grouped_by_severity, -> { reorder(severity: :desc).group(:severity) }
      scope :by_project_fingerprints, -> (project_fingerprints) { joins(:findings).merge(Vulnerabilities::Finding.by_project_fingerprints(project_fingerprints)) }

      scope :with_resolution, -> (has_resolution = true) { where(resolved_on_default_branch: has_resolution) }
      scope :with_issues, -> (has_issues = true) do
        exist_query = has_issues ? 'EXISTS (?)' : 'NOT EXISTS (?)'
        issue_links = ::Vulnerabilities::IssueLink.arel_table

        where(exist_query, ::Vulnerabilities::IssueLink.select(1).where(issue_links[:vulnerability_id].eq(arel_table[:id])))
      end

      scope :order_severity_asc, -> { reorder(severity: :asc, id: :desc) }
      scope :order_severity_desc, -> { reorder(severity: :desc, id: :desc) }
      scope :order_report_type_asc, -> { select(*arel.projections, report_type_order.as('case_order_value')).reorder(report_type_order.asc, id: :desc) }
      scope :order_report_type_desc, -> { select(*arel.projections, report_type_order.as('case_order_value')).reorder(report_type_order.desc, id: :desc) }
      scope :order_state_asc, -> { select(*arel.projections, state_order.as('array_position')).reorder(state_order.asc, id: :desc) }
      scope :order_state_desc, -> { select(*arel.projections, state_order.as('array_position')).reorder(state_order.desc, id: :desc) }

      delegate :scanner_name, :scanner_external_id, :metadata, :message, :description,
               to: :finding, prefix: true, allow_nil: true

      delegate :solution, :identifiers, :links, :remediations, :file,
               :cve_value, :cwe_value, :other_identifier_values,
               to: :finding, allow_nil: true


      def user_notes_count
        user_notes_count_service.count
      end

      def after_note_changed(note)
        user_notes_count_service.delete_cache unless note.system?
      end
      alias_method :after_note_created,   :after_note_changed
      alias_method :after_note_destroyed, :after_note_changed

      private

      def user_notes_count_service
        @user_notes_count_service ||= ::Vulnerabilities::UserNotesCountService.new(self) # rubocop: disable CodeReuse/ServiceClass
      end
    end

    class_methods do
      def counts_by_day_and_severity(start_date, end_date)
        return [] unless ::Feature.enabled?(:vulnerability_history, default_enabled: true)

        num_days_of_history = end_date - start_date + 1

        # this clause guards against query timeouts
        raise TooManyDaysError, "Cannot fetch counts for more than #{MAX_DAYS_OF_HISTORY} days" if num_days_of_history > MAX_DAYS_OF_HISTORY

        quoted_start_date = connection.quote(start_date)
        quoted_end_date = connection.quote(end_date)

        select(
          'DATE(calendar.entry) AS day, severity, COUNT(*)'
        ).from(
          "generate_series(DATE #{quoted_start_date}, DATE #{quoted_end_date}, INTERVAL '1 day') as calendar(entry)"
        ).joins(
          'INNER JOIN vulnerabilities ON vulnerabilities.created_at <= calendar.entry'
        ).where(
          '(vulnerabilities.dismissed_at IS NULL OR vulnerabilities.dismissed_at > calendar.entry) AND (vulnerabilities.resolved_at IS NULL OR vulnerabilities.resolved_at > calendar.entry)'
        ).group(
          :day, :severity
        )
      end

      def report_type_order
        report_types
          .sort
          .to_h
          .values
          .each
          .with_index
          .reduce(Arel::Nodes::Case.new(arel_table[:report_type])) do |node, (value, index)|
            node.when(value).then(index)
          end
      end

      def state_order
        Arel::Nodes::NamedFunction.new(
          'ARRAY_POSITION',
          [
            Arel.sql("ARRAY#{states.values}::smallint[]"),
            arel_table[:state]
          ]
        )
      end

      def active_states
        ACTIVE_STATES
      end

      def passive_states
        PASSIVE_STATES
      end

      def active_state_values
        states.values_at(*active_states)
      end
    end
  end
end
