# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityExternalIssueLinks::CreateService do
  include AccessMatchersGeneric

  before do
    stub_licensed_features(security_dashboard: true)
  end

  let(:user) { create(:user) }
  let(:project) { create(:project) }
  let(:pipeline) { create(:ci_pipeline, :success, project: project) }
  let(:finding) { create(:vulnerabilities_finding, pipelines: [pipeline], project: project, severity: :high) }
  let(:vulnerability) { create(:vulnerability, title: 'My vulnerability', project: project, findings: [finding]) }
  let(:external_provider) { 'jira' }
  let(:service) { described_class.new(user, vulnerability, external_provider) }

  subject(:create_external_issue_link) { service.execute }

  context 'for jira' do
    let(:configured_to_create_issues_from_vulnerabilities) { false }
    let(:jira_service) { double(configured_to_create_issues_from_vulnerabilities?: configured_to_create_issues_from_vulnerabilities, project_key: 'GV') }

    before do
      allow(project).to receive(:jira_service).and_return(jira_service)
    end

    context 'with an authorized user with proper permissions' do
      before do
        project.add_developer(user)
      end

      context 'when jira service is not configured to create issues' do
        it { is_expected.not_to be_success }

        it 'returns response with error messages' do
          expect(subject.message).to eq(['External provider service is not configured to create issues.'])
        end
      end

      context 'when jira service is configured to create issues' do
        let(:configured_to_create_issues_from_vulnerabilities) { true }

        context 'and there is already created external issue link for given vulnerability' do
          before do
            create(:vulnerabilities_external_issue_link, vulnerability: vulnerability)
          end

          it { is_expected.not_to be_success }

          it 'returns response with error messages' do
            expect(subject.message).to eq(['Vulnerability already has a "created" issue link'])
          end
        end

        context 'and there is no external issue link created for given vulnerability' do
          let(:jira_issue_id) { nil }
          let(:errors) { {} }
          let(:jira_issue) { double(has_errors?: errors.present?, id: jira_issue_id, errors: errors) }

          let(:expected_jira_issue_description) do
            <<-JIRA.strip_heredoc
              Issue created from vulnerability [#{vulnerability.id}|http://localhost/#{project.full_path}/-/security/vulnerabilities/#{vulnerability.id}]

              h3. Description:

              Description of My vulnerability

              * Severity: high
              * Confidence: medium
              * Location: [maven/src/main/java/com/gitlab/security_products/tests/App.java:29|http://localhost/#{project.full_path}/-/blob/b83d6e391c22777fca1ed3012fce84f633d7fed0/maven/src/main/java/com/gitlab/security_products/tests/App.java#L29]

              ### Solution:

              See vulnerability [#{vulnerability.id}|http://localhost/#{project.full_path}/-/security/vulnerabilities/#{vulnerability.id}] for any Solution details.


              h3. Links:

              * [Cipher does not check for integrity first?|https://crypto.stackexchange.com/questions/31428/pbewithmd5anddes-cipher-does-not-check-for-integrity-first]


              h3. Scanner:

              * Name: Find Security Bugs
            JIRA
          end

          before do
            allow(jira_service).to receive(:create_issue).and_return(jira_issue)
          end

          it 'creates issue using jira service' do
            expect(jira_service).to receive(:create_issue).with("Investigate vulnerability: #{vulnerability.title}", expected_jira_issue_description)

            subject
          end

          context 'and issue creation fails in Jira' do
            let(:errors) { { 'summary' => 'The issue summary is invalid.' } }

            it { is_expected.not_to be_success }

            it 'returns response with error messages' do
              expect(subject.message).to eq(['The issue summary is invalid.'])
            end
          end

          context 'and issue creation succeeds in Jira' do
            context 'and external issue link creation fails' do
              let(:jira_issue_id) { nil }

              it { is_expected.not_to be_success }

              it 'returns response with error messages' do
                expect(subject.message).to eq(['External issue key can\'t be blank'])
              end
            end

            context 'and external issue link creation succeeds' do
              let(:jira_issue_id) { '10001' }

              it { is_expected.to be_success }

              it 'creates external issue link in database' do
                expect {subject}.to change {::Vulnerabilities::ExternalIssueLink.count}.by(1)
              end

              it 'responds with created external issue link in payload', :aggregate_failures do
                external_issue_link = subject.payload[:record]

                expect(external_issue_link).to be_a(::Vulnerabilities::ExternalIssueLink)
                expect(external_issue_link).to have_attributes(
                  external_type: 'jira',
                  external_project_key: 'GV',
                  external_issue_key: '10001',
                  link_type: 'created',
                  author_id: user.id,
                  vulnerability_id: vulnerability.id
                )
              end
            end
          end
        end
      end
    end

    describe 'permissions' do
      context 'when admin mode enabled', :enable_admin_mode do
        it { expect { create_external_issue_link }.to be_allowed_for(:admin) }
      end
      context 'when admin mode disabled' do
        it { expect { create_external_issue_link }.to be_denied_for(:admin) }
      end
      it { expect { create_external_issue_link }.to be_allowed_for(:owner).of(project) }
      it { expect { create_external_issue_link }.to be_allowed_for(:maintainer).of(project) }
      it { expect { create_external_issue_link }.to be_allowed_for(:developer).of(project) }

      it { expect { create_external_issue_link }.to be_denied_for(:auditor) }
      it { expect { create_external_issue_link }.to be_denied_for(:reporter).of(project) }
      it { expect { create_external_issue_link }.to be_denied_for(:guest).of(project) }
      it { expect { create_external_issue_link }.to be_denied_for(:anonymous) }
    end
  end
end
