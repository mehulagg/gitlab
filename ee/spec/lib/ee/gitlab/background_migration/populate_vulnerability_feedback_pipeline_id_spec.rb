# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::BackgroundMigration::PopulateVulnerabilityFeedbackPipelineId, schema: 2020_10_26_182253 do
  let(:users) { table(:users) }
  let(:namespaces) { table(:namespaces) }
  let(:vulnerability_feedback) { table(:vulnerability_feedback) }
  let(:pipelines) { table(:ci_pipelines) }
  let(:builds) { table(:ci_builds) }
  let(:job_artifacts) { table(:ci_job_artifacts) }
  let(:projects) { table(:projects) }
  let(:namespace) { namespaces.create!(name: 'gitlab', path: 'gitlab-org') }
  let(:user) { users.create!(name: 'test', email: 'test@example.com', projects_limit: 5) }
  let(:timestamp) { Date.current }

  def create_pipeline(project_id, id, finished_at:, status: 'success', with_security_reports: false, with_legacy_security_report: false)
    pipeline_params = { id: id, project_id: project_id, ref: '1', sha: '1', source: 6 }
    pipeline = pipelines.create!(pipeline_params.merge(status: status, finished_at: finished_at))

    if with_security_reports
      build = builds.create!(project_id: project_id, name: 'brakeman', retried: false, commit_id: pipeline.id, type: 'Ci::Build')
      job_artifacts.create!(project_id: project_id, file_format: 'raw', file_type: 5, job_id: build.id)
    elsif with_legacy_security_report
      build = builds.create!(project_id: project_id, name: 'sast', retried: false, commit_id: pipeline.id, type: 'Ci::Build')
      job_artifacts.create!(project_id: project_id, file_format: 'raw', file_type: 101, job_id: build.id)
    end

    pipeline
  end

  def create_project(id)
    project_params = { id: id, namespace_id: namespace.id, name: 'foo' }
    project = projects.create!(project_params)

    pipeline = create_pipeline(project.id, id, finished_at: timestamp - 31.days)

    feedback_params = { project_id: project.id, author_id: user.id, feedback_type: 'dismissal', category: 'sast' }
    vulnerability_feedback.create!(feedback_params.merge(project_fingerprint: SecureRandom.hex, created_at: timestamp - 30.days, pipeline_id: pipeline.id))
    vulnerability_feedback.create!(feedback_params.merge(project_fingerprint: SecureRandom.hex, created_at: timestamp - 15.days))
    vulnerability_feedback.create!(feedback_params.merge(project_fingerprint: SecureRandom.hex, created_at: timestamp - 5.days))
  end

  before do
    create_project(1)
    create_project(2)
  end

  describe '#perform' do
    context 'when there is a succesful pipeline' do
      context 'but the pipeline has no security reports' do
        it 'does not update pipeline_id' do
          subject.perform(1, 999)

          updated_rows = [
            { 'project_id' => 1, 'pipeline_id' => 1,   'created_at' => timestamp - 30.days },
            { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
            { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp -  5.days },
            { 'project_id' => 2, 'pipeline_id' => 2,   'created_at' => timestamp - 30.days },
            { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
            { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp -  5.days }
          ]

          rows = vulnerability_feedback.order(:project_id, :created_at).map do |row|
            row.attributes.slice(*%w(project_id pipeline_id created_at))
          end

          expect(rows).to match_array(updated_rows)
        end
      end

      context 'and the pipeline has security reports' do
        context 'and is not successful' do
          before do
            create_pipeline(1, 3, status: 'failed', finished_at: timestamp - 10.days, with_security_reports: true, with_legacy_security_report: false)
          end

          it 'does not update pipeline_id' do
            subject.perform(1, 999)

            updated_rows = [
              { 'project_id' => 1, 'pipeline_id' => 1,   'created_at' => timestamp - 30.days },
              { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
              { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp -  5.days },
              { 'project_id' => 2, 'pipeline_id' => 2,   'created_at' => timestamp - 30.days },
              { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
              { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp -  5.days }
            ]

            rows = vulnerability_feedback.order(:project_id, :created_at).map do |row|
              row.attributes.slice(*%w(project_id pipeline_id created_at))
            end

            expect(rows).to match_array(updated_rows)
          end
        end

        context 'and is successful' do
          before do
            create_pipeline(1, 3, finished_at: timestamp - 10.days, with_security_reports: true, with_legacy_security_report: false)
          end

          it 'does update pipeline_id for feedback created after pipeline has finished' do
            subject.perform(1, 999)

            updated_rows = [
              { 'project_id' => 1, 'pipeline_id' => 1,   'created_at' => timestamp - 30.days },
              { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
              { 'project_id' => 1, 'pipeline_id' => 3,   'created_at' => timestamp -  5.days },
              { 'project_id' => 2, 'pipeline_id' => 2,   'created_at' => timestamp - 30.days },
              { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
              { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp -  5.days }
            ]

            rows = vulnerability_feedback.order(:project_id, :created_at).map do |row|
              row.attributes.slice(*%w(project_id pipeline_id created_at))
            end

            expect(rows).to match_array(updated_rows)
          end
        end
      end

      context 'and the pipeline has legacy security reports' do
        context 'and is not successful' do
          before do
            create_pipeline(1, 4, status: 'failed', finished_at: timestamp - 10.days, with_security_reports: false, with_legacy_security_report: true)
          end

          it 'does not update pipeline_id' do
            subject.perform(1, 999)

            updated_rows = [
              { 'project_id' => 1, 'pipeline_id' => 1,   'created_at' => timestamp - 30.days },
              { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
              { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp -  5.days },
              { 'project_id' => 2, 'pipeline_id' => 2,   'created_at' => timestamp - 30.days },
              { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
              { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp -  5.days }
            ]

            rows = vulnerability_feedback.order(:project_id, :created_at).map do |row|
              row.attributes.slice(*%w(project_id pipeline_id created_at))
            end

            expect(rows).to match_array(updated_rows)
          end
        end

        context 'and is successful' do
          before do
            create_pipeline(2, 4, finished_at: timestamp - 10.days, with_security_reports: false, with_legacy_security_report: true)
          end

          it 'does update pipeline_id for feedback created after pipeline has finished' do
            subject.perform(1, 999)

            updated_rows = [
              { 'project_id' => 1, 'pipeline_id' => 1,   'created_at' => timestamp - 30.days },
              { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
              { 'project_id' => 1, 'pipeline_id' => nil, 'created_at' => timestamp -  5.days },
              { 'project_id' => 2, 'pipeline_id' => 2,   'created_at' => timestamp - 30.days },
              { 'project_id' => 2, 'pipeline_id' => nil, 'created_at' => timestamp - 15.days },
              { 'project_id' => 2, 'pipeline_id' => 4,   'created_at' => timestamp -  5.days }
            ]

            rows = vulnerability_feedback.order(:project_id, :created_at).map do |row|
              row.attributes.slice(*%w(project_id pipeline_id created_at))
            end

            expect(rows).to match_array(updated_rows)
          end
        end
      end
    end
  end
end
