# frozen_string_literal: true

require 'spec_helper'

describe Gitlab::BackgroundMigration::MigrateVulnerabilityOccurrencesToVulnerabilities, :migration, schema: 20200228111111 do
  let!(:user) { create(:user) }
  let!(:project) { create(:project) }

  let(:scanner) do
    create(:vulnerabilities_scanner, project: project)
  end

  let(:identifiers) do
    [
      create(:vulnerabilities_identifier),
      create(:vulnerabilities_identifier)
    ]
  end

  context 'vulnerability_occurrence exists for latest security report' do
    context 'has no associated vulnerability' do
      let!(:pipeline) { create(:ci_pipeline, project: project, status: 'success', user: user) }
      let!(:vulnerability_occurrence) { create(:vulnerabilities_occurrence, project: project, pipelines: [pipeline]) }

      it 'creates a new vulnerability' do
        expect(Vulnerability.all.count).to eq(0)
        expect(Vulnerabilities::Occurrence.all.count).to eq(1)

        expect { described_class.new.perform(project.id) }.to change { Vulnerability.count }.from(0).to(1)
      end

      context 'has been dismissed' do
        let!(:dismiss_feedback) do
          create(:vulnerability_feedback, :sast, :dismissal,
                 project: project, project_fingerprint: vulnerability_occurrence.project_fingerprint)
        end

        it 'new vulnerability should have state of dismissed' do
          expect(Vulnerability.all.count).to eq(0)
          expect(Vulnerabilities::Occurrence.all.count).to eq(1)

          expect { described_class.new.perform(project.id) }
            .to change { Vulnerability.last&.state }.from(nil).to('dismissed')
        end
      end

      context 'project is archived' do
        let!(:project) { create(:project, archived: true) }

        it 'does it' do
          expect(Vulnerability.all.count).to eq(0)

          expect { described_class.new.perform(project.id) }.not_to change { Vulnerability.count }.from(0)
        end
      end

      context 'project is pending delete' do
        let!(:project) { create(:project, pending_delete: true) }

        it 'does it' do
          expect(Vulnerability.all.count).to eq(0)

          expect { described_class.new.perform(project.id) }.not_to change { Vulnerability.count }.from(0)
        end
      end
    end

    context 'has an associated vulnerability' do
      let!(:vulnerability) { create(:vulnerability, project: project) }
      let!(:pipeline) { create(:ci_pipeline, project: project, status: 'success', user: user) }
      let!(:vulnerability_occurrence) { create(:vulnerabilities_occurrence, project: project, pipelines: [pipeline], vulnerability: vulnerability) }

      it 'does not create a new vulnerability' do
        expect(Vulnerability.all.count).to eq(1)

        expect { described_class.new.perform(project.id) }.not_to change { Vulnerability.count }.from(1)
      end

      context 'has been dismissed' do
        let!(:dismiss_feedback) do
          create(:vulnerability_feedback, :sast, :dismissal,
                 project: project, project_fingerprint: vulnerability_occurrence.project_fingerprint)
        end

        it 'vulnerability should now have state of dismissed' do
          expect(Vulnerability.last.state).to eq('detected')

          expect { described_class.new.perform(project.id) }
            .to change { vulnerability.reload.state }.from('detected').to('dismissed')
        end
      end
    end
  end

  context 'vulnerability_occurrence exists for previous security report' do
    let!(:vulnerability) { create(:vulnerability, project: project) }
    let!(:pipeline1) { create(:ci_pipeline, project: project, status: 'success', user: user) }
    let!(:pipeline2) { create(:ci_pipeline, project: project, status: 'success', user: user) }
    let!(:vulnerability_occurrence) { create(:vulnerabilities_occurrence, project: project, pipelines: [pipeline1], vulnerability: vulnerability) }

    it 'does not create a new vulnerability' do
      expect(Vulnerability.all.count).to eq(1)
      vulnerability_occurrence.pipelines << pipeline2

      expect { described_class.new.perform(project.id) }.not_to change { Vulnerability.count }.from(1)
    end
  end
end
