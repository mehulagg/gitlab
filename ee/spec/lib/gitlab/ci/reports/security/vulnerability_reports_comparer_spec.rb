# frozen_string_literal: true

require 'spec_helper'

describe Gitlab::Ci::Reports::Security::VulnerabilityReportsComparer do
  let!(:identifier) { create(:vulnerabilities_identifier) }
  let!(:base_vulnerability) { build(:vulnerabilities_occurrence, report_type: :sast, identifiers: [identifier], location_fingerprint: '123') }
  let!(:head_vulnerability) { build(:vulnerabilities_occurrence, report_type: :sast, identifiers: [identifier], location_fingerprint: '123') }

  before do
    allow(base_vulnerability).to receive(:location).and_return({})
    allow(head_vulnerability).to receive(:location).and_return({})
  end

  describe '#existing' do
    context 'with existing reports' do
      let(:comparer) { described_class.new([base_vulnerability], [head_vulnerability]) }

      it 'points to source tree' do
        allow(head_vulnerability).to receive(:raw_metadata).and_return('')

        expect(comparer.existing.count).to eq(1)
        expect(comparer.existing).to eq([head_vulnerability])
      end
    end
  end

  describe '#added' do
    let(:vuln) { build(:vulnerabilities_occurrence, report_type: :sast, identifiers: [identifier], location_fingerprint: '888') }

    context 'with new vulnerability' do
      let(:comparer) { described_class.new([base_vulnerability], [head_vulnerability, vuln]) }

      it 'points to source tree' do
        expect(comparer.added.count).to eq(1)
        expect(comparer.added).to eq([vuln])
      end
    end
  end

  describe '#fixed' do
    let(:vuln) { build(:vulnerabilities_occurrence, report_type: :sast, identifiers: [identifier], location_fingerprint: '888') }

    context 'with fixed vulnerability' do
      let(:comparer) { described_class.new([base_vulnerability, vuln], [head_vulnerability]) }

      it 'points to base tree' do
        expect(comparer.fixed.count).to eq(1)
        expect(comparer.fixed).to eq([vuln])
      end
    end
  end

  describe 'with empty vulnerabilities' do
    it 'returns empty array when reports are not present' do
      comparer = described_class.new(nil, nil)

      expect(comparer.existing).to eq([])
      expect(comparer.fixed).to eq([])
      expect(comparer.added).to eq([])
    end

    it 'returns added vulnerability when base is empty and head is not empty' do
      vuln = build(:vulnerabilities_occurrence, report_type: :sast, identifiers: [identifier], location_fingerprint: '888')
      comparer = described_class.new(nil, [vuln])

      expect(comparer.existing).to eq([])
      expect(comparer.fixed).to eq([])
      expect(comparer.added).to eq([vuln])
    end

    it 'returns fixed vulnerability when head is empty and base is not empty' do
      vuln = build(:vulnerabilities_occurrence, report_type: :sast, identifiers: [identifier], location_fingerprint: '888')
      comparer = described_class.new([vuln], nil)

      expect(comparer.existing).to eq([])
      expect(comparer.fixed).to eq([vuln])
      expect(comparer.added).to eq([])
    end
  end
end
