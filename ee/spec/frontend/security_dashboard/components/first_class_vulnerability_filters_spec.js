import { shallowMount } from '@vue/test-utils';
import { initFirstClassVulnerabilityFilters } from 'ee/security_dashboard/helpers';
import Filters from 'ee/security_dashboard/components/first_class_vulnerability_filters.vue';
import Filter from 'ee/security_dashboard/components/filter.vue';

describe('First class vulnerability filters component', () => {
  let wrapper;
  let filters;
  const projects = [
    { id: 'gid://gitlab/Project/11', name: 'GitLab Org' },
    { id: 'gid://gitlab/Project/12', name: 'GitLab Com' },
  ];

  const findFilters = () => wrapper.findAll(Filter);
  const findFirstFilter = () => findFilters().at(0);
  const findLastFilter = () => findFilters().at(filters.length - 1);

  const createComponent = ({ propsData } = {}) => {
    return shallowMount(Filters, { propsData });
  };

  afterEach(() => {
    wrapper.destroy();
    wrapper = null;
  });

  describe('on render without project filter', () => {
    beforeEach(() => {
      wrapper = createComponent();
      filters = initFirstClassVulnerabilityFilters();
    });

    it('should render the filters', () => {
      expect(findFilters()).toHaveLength(filters.length);
    });

    it('should pass down the filter information to the first filter', () => {
      expect(findFirstFilter().props().filter).toEqual(filters[0]);
    });

    it('should call the setFilter mutation when setting a filter', () => {
      const stub = jest.fn();
      const options = { foo: 'bar' };

      wrapper.setMethods({ setFilter: stub });
      findFirstFilter().vm.$emit('setFilter', options);

      expect(stub).toHaveBeenCalledWith(options);
    });
  });

  describe('when project filter is populated dynamically', () => {
    beforeEach(() => {
      filters = initFirstClassVulnerabilityFilters([]);
      wrapper = createComponent({ propsData: { projects: [] } });
    });

    it('should render the project filter with one option', () => {
      expect(findLastFilter().props('filter')).toEqual({
        id: 'projectId',
        name: 'Project',
        options: [{ id: 'all', name: 'All projects' }],
        selection: new Set(['all']),
      });
    });

    it('should set the projects dynamically', () => {
      wrapper.setProps({ projects });
      return wrapper.vm.$nextTick(() => {
        expect(findLastFilter().props('filter')).toEqual(
          expect.objectContaining({
            options: [
              { id: 'all', name: 'All projects' },
              { id: '11', name: 'GitLab Org' },
              { id: '12', name: 'GitLab Com' },
            ],
          }),
        );
      });
    });
  });

  describe('when project filter is ready on mount', () => {
    beforeEach(() => {
      filters = initFirstClassVulnerabilityFilters([]);
      wrapper = createComponent({ propsData: { projects } });
    });

    it('should set the projects dynamically', () => {
      expect(findLastFilter().props('filter')).toEqual(
        expect.objectContaining({
          options: [
            { id: 'all', name: 'All projects' },
            { id: '11', name: 'GitLab Org' },
            { id: '12', name: 'GitLab Com' },
          ],
        }),
      );
    });
  });

  describe('when setFilter is called', () => {
    let filterId;
    let optionId;

    beforeEach(() => {
      filterId = filters[0].id;
      optionId = filters[0].options[1].id;
      wrapper = createComponent();
      wrapper.vm.setFilter({ filterId, optionId });
    });

    it('should set the filters locally', () => {
      const expectedFilters = initFirstClassVulnerabilityFilters();
      expectedFilters[0].selection = new Set([optionId]);

      expect(wrapper.vm.filters).toEqual(expectedFilters);
    });

    it('should emit selected filters when a filter is set', () => {
      expect(wrapper.emitted().filterChange).toBeTruthy();
      expect(wrapper.emitted().filterChange[0]).toEqual([{ [filterId]: [optionId] }]);
    });
  });
});
