import { GlLoadingIcon } from '@gitlab/ui';
import { shallowMount, createLocalVue } from '@vue/test-utils';
import VueApollo from 'vue-apollo';
import CsvExportButton from 'ee/security_dashboard/components/csv_export_button.vue';
import DashboardNotConfiguredGroup from 'ee/security_dashboard/components/empty_states/group_dashboard_not_configured.vue';
import DashboardNotConfiguredInstance from 'ee/security_dashboard/components/empty_states/instance_dashboard_not_configured.vue';
import GroupVulnerabilities from 'ee/security_dashboard/components/first_class_group_security_dashboard_vulnerabilities.vue';
import InstanceVulnerabilities from 'ee/security_dashboard/components/first_class_instance_security_dashboard_vulnerabilities.vue';
import Filters from 'ee/security_dashboard/components/first_class_vulnerability_filters.vue';
import SecurityDashboardLayout from 'ee/security_dashboard/components/security_dashboard_layout.vue';
import SurveyRequestBanner from 'ee/security_dashboard/components/survey_request_banner.vue';
import VulnerabilitiesCountList from 'ee/security_dashboard/components/vulnerability_count_list.vue';
import VulnerabilityReport from 'ee/security_dashboard/components/vulnerability_report.vue';
import vulnerableProjectsGroupQuery from 'ee/security_dashboard/graphql/queries/vulnerable_projects_group.query.graphql';
import vulnerableProjectsInstanceQuery from 'ee/security_dashboard/graphql/queries/vulnerable_projects_instance.query.graphql';
import { DASHBOARD_TYPES } from 'ee/security_dashboard/store/constants';
import createApolloProvider from 'helpers/mock_apollo_helper';
import { mockVulnerableProjectsInstance, mockVulnerableProjectsGroup } from '../mock_data';

describe('Vulnerability Report', () => {
  let wrapper;

  const findSurveyRequestBanner = () => wrapper.findComponent(SurveyRequestBanner);
  const findInstanceVulnerabilities = () => wrapper.findComponent(InstanceVulnerabilities);
  const findGroupVulnerabilities = () => wrapper.findComponent(GroupVulnerabilities);
  const findCsvExportButton = () => wrapper.findComponent(CsvExportButton);
  const findGroupEmptyState = () => wrapper.findComponent(DashboardNotConfiguredGroup);
  const findInstanceEmptyState = () => wrapper.findComponent(DashboardNotConfiguredInstance);
  const findLoadingIcon = () => wrapper.findComponent(GlLoadingIcon);
  const findFilters = () => wrapper.findComponent(Filters);
  const findVulnerabilitiesCountList = () => wrapper.findComponent(VulnerabilitiesCountList);
  const findHeader = () => wrapper.find('h2');

  const createWrapper = ({
    data = {},
    mocks,
    propsData,
    provide = { groupFullPath: undefined },
    apolloProvider,
    stubs,
  }) => {
    const localVue = createLocalVue();

    if (apolloProvider) {
      localVue.use(VueApollo);
    }

    return shallowMount(VulnerabilityReport, {
      localVue,
      apolloProvider,
      data() {
        return { ...data };
      },
      mocks,
      propsData,
      provide,
      stubs: {
        ...stubs,
        SecurityDashboardLayout,
      },
    });
  };

  afterEach(() => {
    wrapper.destroy();
  });

  describe('when initialized - all levels', () => {
    beforeEach(() => {
      wrapper = createWrapper({
        propsData: {
          dashboardType: DASHBOARD_TYPES.INSTANCE,
        },
        apolloProvider: createApolloProvider([
          [
            vulnerableProjectsInstanceQuery,
            jest.fn().mockResolvedValue(mockVulnerableProjectsInstance()),
          ],
        ]),
      });
    });

    it('should show the header', () => {
      expect(findHeader().exists()).toBe(true);
    });

    it('has filters', () => {
      expect(findFilters().exists()).toBe(true);
    });

    it('responds to the filterChange event', () => {
      const filters = { severity: 'critical' };
      findFilters().vm.$listeners.filterChange(filters);
      return wrapper.vm.$nextTick(() => {
        expect(findInstanceVulnerabilities().props('filters')).toEqual(filters);
      });
    });

    it('displays the csv export button', () => {
      expect(findCsvExportButton().exists()).toBe(true);
    });

    it('should show the survey request banner', () => {
      expect(findSurveyRequestBanner().exists()).toBe(true);
    });
  });

  describe('when initialized - instance level', () => {
    beforeEach(() => {
      wrapper = createWrapper({
        propsData: {
          dashboardType: DASHBOARD_TYPES.INSTANCE,
        },
        apolloProvider: createApolloProvider([
          [
            vulnerableProjectsInstanceQuery,
            jest.fn().mockResolvedValue(mockVulnerableProjectsInstance()),
          ],
        ]),
      });
    });

    it('should render the vulnerabilities', () => {
      expect(findInstanceVulnerabilities().exists()).toBe(true);
    });

    it('displays the vulnerability count list with the correct data', () => {
      expect(findVulnerabilitiesCountList().props()).toMatchObject({
        scope: 'instance',
        filters: wrapper.vm.filters,
      });
    });
  });

  describe('when initialized - group level', () => {
    beforeEach(() => {
      wrapper = createWrapper({
        propsData: {
          dashboardType: DASHBOARD_TYPES.GROUP,
        },
        provide: {
          groupFullPath: 'gitlab-org',
        },
        apolloProvider: createApolloProvider([
          [
            vulnerableProjectsGroupQuery,
            jest.fn().mockResolvedValue(mockVulnerableProjectsGroup()),
          ],
        ]),
      });
    });

    it('should render the vulnerabilities', () => {
      expect(findGroupVulnerabilities().exists()).toBe(true);
    });

    it('displays the vulnerability count list with the correct data', () => {
      expect(findVulnerabilitiesCountList().props()).toEqual({
        scope: 'group',
        fullPath: 'gitlab-org',
        filters: wrapper.vm.filters,
      });
    });
  });

  describe('when uninitialized', () => {
    beforeEach(() => {
      wrapper = createWrapper({
        propsData: { dashboardType: DASHBOARD_TYPES.GROUP },
        provide: { groupFullPath: 'gitlab-org' },
        apolloProvider: createApolloProvider([
          [
            vulnerableProjectsGroupQuery,
            jest.fn().mockResolvedValue({ data: { group: { projects: { nodes: [] } } } }),
          ],
        ]),
      });
    });

    it('only renders the empty state', () => {
      expect(findGroupEmptyState().exists()).toBe(true);
      expect(findInstanceEmptyState().exists()).toBe(false);
      expect(findCsvExportButton().exists()).toBe(false);
      expect(findFilters().exists()).toBe(false);
      expect(findVulnerabilitiesCountList().exists()).toBe(false);
      expect(findHeader().exists()).toBe(false);
    });

    it('should show the survey request banner', () => {
      expect(findSurveyRequestBanner().exists()).toBe(true);
    });
  });

  describe('when loading projects', () => {
    beforeEach(() => {
      wrapper = createWrapper({
        propsData: { dashboardType: DASHBOARD_TYPES.INSTANCE },
        mocks: { $apollo: { queries: { projects: { loading: true } } } },
      });
    });

    it('renders the loading icon', () => {
      expect(findLoadingIcon().exists()).toBe(true);
    });

    it('does not render the export button, vulnerabilities count list, or header', () => {
      expect(findCsvExportButton().exists()).toBe(false);
      expect(findVulnerabilitiesCountList().exists()).toBe(false);
      expect(findHeader().exists()).toBe(false);
    });

    it('should not show the survey request banner', () => {
      expect(findSurveyRequestBanner().exists()).toBe(false);
    });
  });
});
