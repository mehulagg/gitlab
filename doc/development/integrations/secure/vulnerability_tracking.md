---
stage: Protect
group: Container Security
info: To determine the technical writer assigned to the Stage/Group associated with this page, see https://about.gitlab.com/handbook/engineering/ux/technical-writing/#assignments
---

# Vulnerability Tracking

Determining if a vulnerability in one version of a project is the same
vulnerability as in another version of the project is a challenge. Code is
added, removed, edited, shifted, auto-formatted, etc. as the project grows.

This makes straightforward location-based approaches to tracking
vulnerabilities (file-name and line-number) fragile.

- [Distinct Vulnerabilities](#distinct-vulnerabilities)
- [General Architecture](#general-architecture)
- [Comparing Vulnerabilities](#comparing-vulnerabilities)
- [Workflows](#workflows)

## Distinct Vulnerabilities

Deciding whether a vulnerability in one version of a project is the same as
a vulnerability in another version of a project cannot be done without a clear
definition of what makes one vulnerability distinct from another.

In other words, how much would lines of source code that contain a
vulnerablity have to be changed before the vulnerability should be considered a
new, or distinct vulnerability?

In GitLab, the following changes will cause a vulnerability to be considered a
distinct vulnerability from one found in a previous version of the code:

- Scope
- Tracking fingerprint
- Vulnerability type

### Scope Change

The scope of a vulnerability is the context in which the vulnerability is found.

For example, the vulnerability below is in the scope
`custom_widget.rb > Widgets > CustomWidget > run`:

```ruby
# file custom_widget.rb

module Widgets
  class CustomWidget
    def run(user_supplied_arg)
      exec("echo #{user_supplied_arg}") # << Vulnerability
    end
  end
end
```

The exact scope calculation used for a vulnerability's location depends on
the supported algorithms for the source file language. In the default case
where no advanced algorithms are available for a source language, the scope of
the vulnerability is the file itself.

### Tracking Fingerprint Change

The tracking fingerprint is a unique, algorithm-specific value used to track
a vulnerability within a scope. The default case is for the filename to
be the scope, and the line number to be the location within the scope.

### Vulnerability Type Change

The type of a vulnerability classifies the type of flaw present in the code.

The previous example contained a command injection vulnerability
([CWE-78](https://cwe.mitre.org/data/definitions/78.html)):

```ruby
exec("echo #{user_supplied_arg}") # << Vulnerability
```

If the `exec` exec call instead ran the `ls` command, using a shell-escaped,
user-supplied argument to construct the path, the code could now contain a
directory traversal vulnerability
([CWE-23](https://cwe.mitre.org/data/definitions/23.html)):

```ruby
exec("ls base/path/#{escaped_user_arg}")
```

## General Architecture

Vulnerability tracking in GitLab is based on the following concepts:

- Security analyzers can declare how vulnerabilities should be tracked
- Each vulnerability can have multiple tracking fingerprints

### Analyzer Tracking Declaration

Analyzers declare how the vulnerabilities they detect can be tracked via a
`tracking` field in the vulnerability JSON report produced in a pipeline:

```javascript
{
  // ...
  "vulnerabilities": [
    {
      // ...
      "tracking": {
        "type": "source",
        "positions": [
          { "file": "path/to/file1.ext", "line_start": 10, "line_end": 20 },
          { "file": "path/to/file2.ext", "line_start": 10, "line_end": 20 },
          { "file": "path/to/file3.ext", "line_start": 10, "line_end": 20 }
        ]
      },
      // ...
    }
  ],
}
```

See the [TODO SCHEMA DOCUMENTATION]() for details on the `tracking` field.

Once the tracking type is declared by the analyzer, GitLab calculates a
unique tracking fingerprint for the vulnerability using the best available
fingerprinting algorithms for the source language.

### Multiple Tracking Fingerprints

Each vulnerability may have multiple tracking fingerprints, one each for each
applicable fingerprint algorithm. This enables:

- Backwards compatability
    - Newly deployed tracking algorithms build on top of existing tracking
        fingerprints
- Priority-based matching
    - Fingerprints are matched based on priority, with higher-priority and
        more accurate fingerprinting algorithms having first say if two
        vulnerabilities are a match.

### Tracking Algorithm Implementation

Tracking algorithm implementations are run as a post-analyzer in a pipeline job
after the analyzer runs. The post-analyzer enriches the JSON report that was
produced by the analyzer to include the tracking fingerprint values.

## Comparing Vulnerabilities

Each tracking fingerprint algorithm has a priority defined in the GitLab backend.
Vulnerabilities with matching tracking fingerprint values are compared in
order of descending priority.

Below are a few scenarios to demonstrate how this works:

<details>
<summary>One matching lower-priority fingerprint</summary>
<br/>

In this example, `Vuln1`'s `Source:Hash` tracking fingerprint is the only
match with `Vuln2`'s tracking fingerprints. As this is the first
and only match, they are considered the same vulnerability.

This scenario is expected to occur when tracking algorithms are initially
deployed.

```mermaid
graph LR
  subgraph Vuln1
    subgraph fingerprint11[fingerprint1]
      type11["Type:Source"]
      method11["Method:Scope+Offset"]
      value11["Hash:AAAA"]
    end
    subgraph fingerprint12[fingerprint2]
      type12["Type:Source"]
      method12["Method:Hash"]
      value12["Hash:XXXX"]
    end
  end

  subgraph Vuln2
    subgraph fingerprint22[fingerprint2]
      type22["Type:Source"]
      method22["Method:Hash"]
      value22["Hash:XXXX"]
    end
  end

  type12 -->|matches| type22
  method12 -->|matches| method22
  value12 -->|matches| value22

  classDef green fill:#9f9,stroke-width:4px,font-weight:bold;
  classDef red fill:#f9f,stroke:#333,stroke-width:4px;

  class fingerprint22 green
  class fingerprint12 green
```

</details>

<details>
<summary>Two matching fingerprints</summary>
<br />

In this example, `Vuln1` and `Vuln2` have several matching fingerprints.
However, the first and highest priority (most accurate) match is with the
`Source:Scope+Offset` tracking fingerprint. As a successful match was found,
the two vulnerabilities are considered the same vulnerability.

This scenario is expected to be a common case.

```mermaid
graph LR
  subgraph Vuln1
    subgraph fingerprint11[fingerprint1]
      priority11["Priority:2"]
      type11["Type:Source"]
      method11["Method:Scope+Offset"]
      value11["Hash:AAAA"]
    end
    subgraph fingerprint12[fingerprint2]
      priority12["Priority:1"]
      type12["Type:Source"]
      method12["Method:Hash"]
      value12["Hash:XXXX"]
    end
  end

  subgraph Vuln2
    subgraph fingerprint21[fingerprint1]
      priority21["Priority:2"]
      type21["Type:Source"]
      method21["Method:Scope+Offset"]
      value21["Hash:AAAA"]
    end
    subgraph fingerprint22[fingerprint2]
      priority22["Priority:1"]
      type22["Type:Source"]
      method22["Method:Hash"]
      value22["Hash:XXXX"]
    end
  end

  priority11-->|matches| priority21
  type11 -->|matches| type21
  method11 -->|matches| method21
  value11 -->|matches| value21

  priority12-.->|matches| priority22
  type12 -.->|matches| type22
  method12 -.->|matches| method22
  value12 -.->|matches| value22

  classDef green fill:#9f9,stroke-width:4px,font-weight:bold;
  classDef red fill:#f9f,stroke:#333,stroke-width:4px;

  class fingerprint11 green
  class fingerprint21 green
```

</details>

<details>
<summary>Non-matching high priority fingerprints & matching low-priority fingerprints</summary>
<br/>

Prioritized tracking fingerprints are also used to **disprove** matches.

In the example below, `Vuln1` and `Vuln2` both have matching low-priority
`Source:Hash` fingerprints, but the high-priority `Source:Scope+Offset`
tracking fingerprints do not match. As the highest-priority fingerprints
exist in both `Vuln1` and `Vuln2`, but do not match, it is determined that
`Vuln1` and `Vuln2` are not the same vulnerability.

This scenario should be uncommon, but may occur. In this case, defaulting to the
fingerprinting algorithm with the highest accuracy is desired.

```mermaid
graph LR
  subgraph Vuln1
    subgraph fingerprint11[fingerprint1]
      priority11["Priority:2"]
      type11["Type:Source"]
      method11["Method:Scope+Offset"]
      value11["Hash:AAAA"]
    end
    subgraph fingerprint12[fingerprint2]
      priority12["Priority:1"]
      type12["Type:Source"]
      method12["Method:Hash"]
      value12["Hash:XXXX"]
    end
  end

  subgraph Vuln2
    subgraph fingerprint21[fingerprint1]
      priority21["Priority:2"]
      type21["Type:Source"]
      method21["Method:Scope+Offset"]
      value21["Hash:BBBB"]
    end
    subgraph fingerprint22[fingerprint2]
      priority22["Priority:1"]
      type22["Type:Source"]
      method22["Method:Hash"]
      value22["Hash:XXXX"]
    end
  end

  priority11-->|"✗"| priority21
  type11 -->|"✗"| type21
  method11 -->|"✗"| method21
  value11 -->|"✗"| value21

  priority12-.->|matches| priority22
  type12 -.->|matches| type22
  method12 -.->|matches| method22
  value12 -.->|matches| value22

  classDef green fill:#9f9,stroke-width:4px,font-weight:bold;
  classDef red fill:#f99,stroke-width:4px,font-weight:bold;

  class fingerprint11 red
  class fingerprint21 red
```

</details>

## Workflows

- [Vulnerability Finding Comparisons](#vulnerability-finding-comparisons)
- [Pipeline Vulnerabilitiles](#pipeline-vulnerabilities-workflow)
- [Default Branch](#default-branch-workflow)

### Vulnerability Finding Comparisons

Vulnerability findings are compared to eachother using the `eql?` method on
the [`Vulnerabilities::Finding`](https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/models/vulnerabilities/finding.rb#L339-343)
model.

### Pipeline Vulnerabilities Workflow

_**Note** The module/class nodes in the flow charts below are clickable._

The flow chart below shows the process of comparing security vulnerabilities
from a pipeline with known vulnerabilities in the project.

This usually occurs in the context of a merge request in a merge request widget:

<details>
<summary>Flow chart</summary>
<br/>

```mermaid
graph TD
    subgraph EE::Projects::MergeRequestsController
        sast_reports["sast_reports()"]
    end

    subgraph EE::MergeRequest
        compare_sast_reports["compare_sast_reports()"]
    end

    subgraph Ci::CompareReportsBaseService
        execute

        subgraph Ci::CompareSecurityReportsService
            comparer["comparer_class"]
            serializer["serializer_class"]
            get_report
        end
    end

    sast_reports --> compare_sast_reports

    comparer --> Ci::Reports::Security::VulnerabilityReportsComparer
    serializer --> Vulnerabilities::FindingDiffSerializer
    get_report --> Security::PipelineVulnerabilitiesFinder

    compare_sast_reports -->|sast| execute
    execute --> comparer
    Security::PipelineVulnerabilitiesFinder -->|head_report| Ci::Reports::Security::VulnerabilityReportsComparer
    Security::PipelineVulnerabilitiesFinder -->|base_report| Ci::Reports::Security::VulnerabilityReportsComparer
    Ci::Reports::Security::VulnerabilityReportsComparer --> result
    result --> Vulnerabilities::FindingDiffSerializer

    click execute "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/app/services/ci/compare_reports_base_service.rb#L10-28"
    click sast_reports "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/controllers/ee/projects/merge_requests_controller.rb#L48-50"
    click compare_sast_reports "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/models/ee/merge_request.rb#L204-208"
    click comparer "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/ci/compare_security_reports_service.rb"
    click serializer "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/ci/compare_security_reports_service.rb"
    click get_report "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/ci/compare_security_reports_service.rb"
    click Ci::Reports::Security::VulnerabilityReportsComparer "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/lib/gitlab/ci/reports/security/vulnerability_reports_comparer.rb"
    click Vulnerabilities::FindingDiffSerializer "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/serializers/vulnerabilities/finding_diff_serializer.rb"
    click Security::PipelineVulnerabilitiesFinder "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/finders/security/pipeline_vulnerabilities_finder.rb"
```

</details>

The [`Ci::Reports::Security::VulnerabilityReportsComparer`](https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/lib/gitlab/ci/reports/security/vulnerability_reports_comparer.rb)
class contains `added` and `fixed` methods that are used to display the number
of added and fixed vulnerabilities in the merge request widget.

### Default Branch Workflow

_**Note** The module/class nodes in the flow charts below are clickable._

The flow chart below shows the process of storing security vulnerabilities
from a pipeline into the database:

<details>
<summary>Flow chart</summary>
<br/>

```mermaid
graph LR
    subgraph Pipeline
        AnalyzerJob
    end

    subgraph GitlabBackend
        artifact_storage["Artifact Storage"]
        state_machine[EE::Ci::Pipeline state machine]
        processing["Rest of the workflow"]
    end

    AnalyzerJob -->|artifact_report| artifact_storage
    AnalyzerJob -->|pipeline_complete| state_machine
    state_machine --> processing

    click state_machine "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/models/ee/ci/pipeline.rb#L54-59" "EE::Ci::Pipeline"
```

</details>

`EE::Ci::Pipeline` [contains a state machine](https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/models/ee/ci/pipeline.rb#L54-59)
that performs actions when pipelines change state.

For security reports and pipeline vulnerabilities, the rest of the workflow
goes as follows:

<details>
<summary>Flow chart</summary>
<br/>

```mermaid
graph TD
    EE::Ci::Pipeline -->|async, IF default branch| StoreSecurityReportsWorker
    StoreSecurityReportsWorker --> StoreSecurityReportsService

    subgraph StoreSecurityReportService
        execute
        create_vulnerability_finding
    end

    StoreSecurityReportsService -->|for each security report| execute
    execute -->|for each finding| create_vulnerability_finding
    create_vulnerability_finding -->|if already exists| Vulnerabilities::UpdateService
    create_vulnerability_finding -->|if doesn't exist| Vulnerabilities::CreateService

    click Ci::Pipeline "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/models/ee/ci/pipeline.rb#L54-59" "Ci::Pipeline"
    click StoreSecurityReportsWorker "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/workers/store_security_reports_worker.rb" "StoreSecurityReportsWorker"
    click StoreSecurityReportsService "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/security/store_reports_service.rb" "StoreSecurityReportsService"
    click execute "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/security/store_report_service.rb#L17-27" "StoreSecurityReportService"
    click create_vulnerability_finding "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/security/store_report_service.rb#L46-71" "create_vulnerability_finding"
    click Vulnerabilities::UpdateService "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/vulnerabilities/update_service.rb" "Vulnerabilities::UpdateService"
    click Vulnerabilities::CreateService "https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/vulnerabilities/create_service.rb" "Vulnerabilities::CreateService"
```

</details>

The [`EE::Vulnerabilities::StoreSecurityReportService`](https://gitlab.com/gitlab-org/gitlab/-/blob/v13.8.1-ee/ee/app/services/security/store_report_service.rb)
service contains the logic to compare all vulnerablity findings from the
pipeline with the vulnerability findings already stored in the database.
