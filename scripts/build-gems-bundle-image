#!/bin/bash

# Exit early if we don't want to build the image
if [[ "${BUILD_GEMS_BUNDLE_IMAGE}" != "true" ]]
then
    exit 0
fi

# Generate the image name based on the project this is being run in
GEMS_BUNDLE_IMAGE_NAME="gitlab-gems-bundle-ce"
# `dev.gitlab-org` still has gitlab-ee.
if [[ "${CI_PROJECT_NAME}" == "gitlab" ]] || [[ "${CI_PROJECT_NAME}" == "gitlab-ee" ]]
then
  GEMS_BUNDLE_IMAGE_NAME="gitlab-gems-bundle-ee"
fi

GEMS_BUNDLE_IMAGE_PATH="${CI_REGISTRY}/${CI_PROJECT_PATH}/${GEMS_BUNDLE_IMAGE_NAME}"
GEMS_BUNDLE_IMAGE_GEMFILE_LOCK="${GEMS_BUNDLE_IMAGE_PATH}:${GITLAB_GEMS_BUNDLE_TAG}"
GEMS_BUNDLE_IMAGE_MASTER="${GEMS_BUNDLE_IMAGE_PATH}:master"
CONTEXT_DIR="bundled_gems_container.build/"
DOCKERFILE="Dockerfile.gems_bundle"

# Only build/push if the image doesn't exist since it's versioned with the Ruby version and the MD5 sum of Gemfile.lock
if ! $(docker pull ${GEMS_BUNDLE_IMAGE_GEMFILE_LOCK} > /dev/null); then
  mkdir -p "${CONTEXT_DIR}vendor/bundle"
  cp -r vendor/ruby "${CONTEXT_DIR}vendor/bundle/"
  cp "${DOCKERFILE}" "${CONTEXT_DIR}"
  docker build --cache-from ${GEMS_BUNDLE_IMAGE_MASTER} --tag ${GEMS_BUNDLE_IMAGE_GEMFILE_LOCK} --file "${CONTEXT_DIR}${DOCKERFILE}" "${CONTEXT_DIR}"

  docker login -u gitlab-ci-token -p ${CI_JOB_TOKEN} ${CI_REGISTRY}
  docker push ${GEMS_BUNDLE_IMAGE_GEMFILE_LOCK}
fi

if [[ "${CI_COMMIT_REF_NAME}" == "master" ]]; then
  docker tag ${GEMS_BUNDLE_IMAGE_GEMFILE_LOCK} ${GEMS_BUNDLE_IMAGE_MASTER}
  docker push ${GEMS_BUNDLE_IMAGE_MASTER}
fi

# Also tag the image with GitLab version, if running on a tag pipeline, so
# other projects can simply use that instead of computing the slug.
if [ -n "$CI_COMMIT_TAG" ]; then
    docker tag ${GEMS_BUNDLE_IMAGE_GEMFILE_LOCK} ${GEMS_BUNDLE_IMAGE_PATH}:${CI_COMMIT_REF_NAME}
    docker push ${GEMS_BUNDLE_IMAGE_PATH}:${CI_COMMIT_REF_NAME}
fi
