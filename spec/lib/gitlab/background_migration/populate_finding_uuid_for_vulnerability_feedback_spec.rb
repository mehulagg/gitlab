# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::BackgroundMigration::PopulateFindingUuidForVulnerabilityFeedback, schema: 20201211090634 do
  let(:namespaces) { table(:namespaces) }
  let(:projects) { table(:projects) }
  let(:users) { table(:users) }
  let(:scanners) { table(:vulnerability_scanners) }
  let(:identifiers) { table(:vulnerability_identifiers) }
  let(:findings) { table(:vulnerability_occurrences) }

  let(:namespace) { namespaces.create!(name: 'gitlab', path: 'gitlab-org') }
  let(:project) { projects.create!(namespace_id: namespace.id, name: 'foo') }
  let(:scanner_1) { scanners.create!(project_id: project_1.id, external_id: 'foo', name: 'bar') }
  let(:scanner_2) { scanners.create!(project_id: project_2.id, external_id: 'foo', name: 'bar') }
  let(:identifier_1) { identifiers.create!(project_id: project_1.id, fingerprint: 'foo', external_type: 'bar', external_id: 'zoo', name: 'baz') }
  let(:identifier_2) { identifiers.create!(project_id: project_2.id, fingerprint: 'foo', external_type: 'bar', external_id: 'zoo', name: 'baz') }
  let(:existing_diff) { 'existing diff' }
  let(:existing_checksum) { [Digest::SHA256.hexdigest(existing_diff)].pack('H*') }
  let(:long_summary_text) { 'a' * 300 }
  let(:empty_metadata) { '{}' }
  let(:broken_metadata) { '{' }
  let(:primitive_metadata) { '""' }
  let(:empty_remediations) { { remediations: [] }.to_json }
  let(:null_remediation) { { remediations: [nil] }.to_json }
  let(:existing_remediation_data) { { remediations: [{ summary: 'Foo', diff: existing_diff }] }.to_json }
  let(:remediation_without_summary) { { remediations: [{ diff: '...' }] }.to_json }
  let(:remediation_1) { { remediations: [{ summary: 'Foo', diff: 'Zoo' }] }.to_json }
  let(:remediation_2) { { remediations: [{ summary: long_summary_text, diff: 'Taz' }] }.to_json }
  let(:remediation_3) { { remediations: [{ summary: 'Foo', diff: 'Zoo' }, { summary: 'Baz', diff: 'Taz' }] }.to_json }
  let(:finding_base_params) { { name: 'Foo', project_fingerprint: 'bar', metadata_version: '1', severity: 0, confidence: 5, report_type: 2 } }
  let(:finding_creator) do
    -> (project, identifier, scanner, raw_metadata) do
      findings.create!(
        project_id: project.id,
        primary_identifier_id: identifier.id,
        scanner_id: scanner.id,
        raw_metadata: raw_metadata,
        uuid: SecureRandom.uuid,
        location_fingerprint: Digest::SHA256.hexdigest(SecureRandom.uuid),
        **finding_base_params
      )
    end
  end

  let!(:finding_1) { finding_creator.call(project_1, identifier_1, scanner_1, empty_metadata) }
  let!(:finding_2) { finding_creator.call(project_1, identifier_1, scanner_1, broken_metadata) }
  let!(:finding_3) { finding_creator.call(project_1, identifier_1, scanner_1, primitive_metadata) }
  let!(:finding_4) { finding_creator.call(project_1, identifier_1, scanner_1, empty_remediations) }
  let!(:finding_5) { finding_creator.call(project_1, identifier_1, scanner_1, null_remediation) }
  let!(:finding_6) { finding_creator.call(project_1, identifier_1, scanner_1, remediation_without_summary) }
  let!(:finding_7) { finding_creator.call(project_1, identifier_1, scanner_1, remediation_1) }
  let!(:finding_8) { finding_creator.call(project_1, identifier_1, scanner_1, remediation_2) }
  let!(:finding_9) { finding_creator.call(project_1, identifier_1, scanner_1, remediation_3) }
  let!(:finding_10) { finding_creator.call(project_2, identifier_2, scanner_2, remediation_3) }
  let!(:finding_11) { finding_creator.call(project_2, identifier_2, scanner_2, existing_remediation_data) }

  subject(:populate_vulnerability_remediations) { described_class.new.perform(project_1, project_2) }

  before do
    remediations.create!(project_id: project_2.id, summary: 'Foo', checksum: existing_checksum, file: 'file_path')

    allow(Gitlab::BackgroundMigration::Logger).to receive_messages(info: true, warn: true)
  end

  describe '#perform' do
    it 'creates remediation entries in the database' do
      expect { populate_vulnerability_remediations }.to change { remediations.count }.from(1).to(5)

      expect(Gitlab::BackgroundMigration::Logger).to have_received(:warn).once
      expect(Gitlab::BackgroundMigration::Logger).to have_received(:info).once
    end
  end
end
