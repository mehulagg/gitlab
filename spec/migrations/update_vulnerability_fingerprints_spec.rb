require 'spec_helper'
require Rails.root.join('db', 'post_migrate', '20190726141000_update_vulnerability_fingerprints.rb')

describe UpdateVulnerabilityFingerprints, :migration do
  let(:namespaces) { table(:namespaces) }
  let(:projects) { table(:projects) }
  let(:vulnerability_feedback) { table(:vulnerability_feedback) }
  let(:vulnerability_identifiers) { table(:vulnerability_identifiers) }
  let(:vulnerability_occurrences) { table(:vulnerability_occurrences) }
  let(:vulnerability_scanners) { table(:vulnerability_scanners) }
  let(:users) { table(:users) }

  let(:namespace) { namespaces.create(name: 'gitlab', path: 'gitlab') }
  let(:project) { projects.create(name: 'gitlab', path: 'gitlab', namespace_id: namespace.id) }
  let(:scanner) { vulnerability_scanners.create(name: 'Scanner', project_id: project.id, external_id: 1) }
  let(:user) { users.create(projects_limit: 1) }
  let(:identifier) do
    vulnerability_identifiers.create(
      external_id: 1,
      external_type: 'id',
      fingerprint: '111',
      name: 'Identifier',
      project_id: project.id
    )
  end

  describe '#up' do
    it 'updates project_fingerprint on feedback for dependency scanning vulnerabilities' do
      vulnerability_metadata = { 'cve' => 'new_fingerprint', 'message' => 'old_fingerprint' }
      old_fingerprint = Digest::SHA1.hexdigest(vulnerability_metadata['message'])
      new_fingerprint = Digest::SHA1.hexdigest(vulnerability_metadata['cve'])
      create_occurrence(fingerprint: new_fingerprint, metadata: vulnerability_metadata, report_type: 1)
      feedback = create_feedback(fingerprint: old_fingerprint)

      migrate!

      expect(feedback.reload.project_fingerprint).to eq(new_fingerprint)
    end

    it 'updates project_fingerprint on feedback for container scanning vulnerabilities' do
      vulnerability_metadata = {
        'featurename' => 'old_fingerprint',
        'featureversion' => 'old_fingerprint',
        'namespace' => 'old_fingerprint',
        'vulnerability' => 'new_fingerprint'
      }
      old_fingerprint = Digest::SHA1.hexdigest(
        "#{vulnerability_metadata['namespace']}:#{vulnerability_metadata['vulnerability']}" \
        ":#{vulnerability_metadata['featurename']}:#{vulnerability_metadata['featureversion']}"
      )
      new_fingerprint = Digest::SHA1.hexdigest(vulnerability_metadata['vulnerability'])
      create_occurrence(fingerprint: new_fingerprint, metadata: vulnerability_metadata, report_type: 2)
      feedback = create_feedback(fingerprint: old_fingerprint)

      migrate!

      expect(feedback.reload.project_fingerprint).to eq(new_fingerprint)
    end

    context 'when a feedback of the same type with a new fingerprint exists' do
      it 'deletes the old feedback' do
        vulnerability_metadata = { 'cve' => 'new_fingerprint', 'message' => 'old_fingerprint' }
        old_fingerprint = Digest::SHA1.hexdigest(vulnerability_metadata['message'])
        new_fingerprint = Digest::SHA1.hexdigest(vulnerability_metadata['cve'])
        create_occurrence(fingerprint: new_fingerprint, metadata: vulnerability_metadata, report_type: 1)
        old_feedback = create_feedback(fingerprint: old_fingerprint)
        _new_feedback = create_feedback(fingerprint: new_fingerprint)

        migrate!

        expect { old_feedback.reload }.to raise_error(ActiveRecord::RecordNotFound)
      end
    end
  end

  def create_occurrence(fingerprint:, metadata:, report_type:)
    vulnerability_occurrences.create(
      confidence: 1,
      location_fingerprint: Digest::SHA1.hexdigest('location'),
      metadata_version: '1.0.0',
      name: 'Vuln',
      primary_identifier_id: identifier.id,
      project_fingerprint: [fingerprint].pack(::Gitlab::Database::ShaAttribute::PACK_FORMAT),
      project_id: project.id,
      raw_metadata: metadata.to_json,
      report_type: report_type,
      scanner_id: scanner.id,
      severity: 1,
      uuid: SecureRandom.uuid
    )
  end

  def create_feedback(fingerprint:)
    vulnerability_feedback.create(
      author_id: user.id,
      category: 1,
      feedback_type: 0,
      project_fingerprint: fingerprint,
      project_id: project.id
    )
  end
end
