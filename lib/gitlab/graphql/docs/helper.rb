# frozen_string_literal: true

return if Rails.env.production?

module Gitlab
  module Graphql
    module Docs
      CONNECTION_ARGS = %w[after before first last].to_set

      FIELD_HEADER = <<~MD
        #### fields

        | Name | Type | Description |
        | ---- | ---- | ----------- |
      MD

      ARG_HEADER = <<~MD
        # arguments

        | Name | Type | Description |
        | ---- | ---- | ----------- |
      MD

      # Helper with functions to be used by HAML templates
      # This includes graphql-docs gem helpers class.
      # You can check the included module on: https://github.com/gjtorikian/graphql-docs/blob/v1.6.0/lib/graphql-docs/helpers.rb
      module Helper
        include GraphQLDocs::Helpers

        def auto_generated_comment
          <<-MD.strip_heredoc
            ---
            stage: Plan
            group: Project Management
            info: To determine the technical writer assigned to the Stage/Group associated with this page, see https://about.gitlab.com/handbook/engineering/ux/technical-writing/#designated-technical-writers
            ---

            <!---
              This documentation is auto generated by a script.

              Please do not edit this file directly, check compile_docs task on lib/tasks/gitlab/graphql.rake.
            --->
          MD
        end

        def render_full_field(field, level = 3, owner = nil)
          conn = connection?(field)
          args = field[:arguments].reject { |f| conn && CONNECTION_ARGS.include?(f[:name]) }
          arg_owner = [owner, field[:name]]

          [
            render_name_and_description(field, level, owner),
            render_return_type(field),
            render_input_type(field),
            render_connection_note(field),
            render_argument_table(level, args, arg_owner)
          ].compact.join("\n\n")
        end

        def render_argument_table(level, args, owner)
          arg_header = ('#' * level) + ARG_HEADER
          render_field_table(arg_header, args, owner)
        end

        def render_connection_note(field)
          return unless connection?(field)

          <<~MD.chomp
          This field returns a [connection](#connections). It accepts the
          four standard [pagination arguments](#connection-pagination-arguments):
          `before: String`, `after: String`, `first: Int`, `last: Int`.
          MD
        end

        def render_field_table(header, fields, owner)
          return if fields.empty?

          fields = sorted_by_name(fields)
          header + fields.map { |f| render_field(f, owner) }.join("\n")
        end

        def render_object_fields(fields, owner, bump = 0)
          return if fields.empty?

          (simple, has_args) = fields.partition { |f| simple?(f) }
          type_name = owner[:name] if owner
          extra_level = '#' * bump

          [
            simple_fields(simple, type_name, extra_level),
            fields_with_arguments(has_args, type_name, extra_level)
          ].compact.join("\n\n")
        end

        def simple?(field)
          return true if field[:arguments].empty?

          if connection?(field)
            field[:arguments].all? { |arg| CONNECTION_ARGS.include?(arg[:name]) }
          else
            false
          end
        end

        def connection?(field)
          type_name = field.dig(:type, :name)
          type_name.present? && type_name.ends_with?('Connection')
        end

        def simple_fields(fields, type_name, header_prefix)
          render_field_table(header_prefix + FIELD_HEADER, fields, type_name)
        end

        def fields_with_arguments(fields, type_name, header_prefix)
          return if fields.empty?

          level = 5 + header_prefix.length

          <<~MD.chomp
            #{header_prefix}#### fields with arguments

            #{sorted_by_name(fields).map { |f| render_full_field(f, level, type_name) }.join("\n\n")}
          MD
        end

        def render_name_and_description(object, level = 3, owner = nil)
          content = []

          heading = '#' * level
          name = owner ? "#{owner}.#{object[:name]}" : object[:name]

          content << "#{heading} `#{name}`"
          content << render_description(object, owner, :block)

          content.compact.join("\n\n")
        end

        def sorted_by_name(objects)
          return [] unless objects.present?

          objects.sort_by { |o| o[:name] }
        end

        def render_field(field, owner)
          row(
            render_name(field, owner),
            render_field_type(field[:type]),
            render_description(field, owner, :inline)
          )
        end

        def render_enum_value(enum, value)
          row(render_name(value, enum[:name]), render_description(value, enum[:name], :inline))
        end

        def row(*values)
          "| #{values.map { |val| val.to_s.gsub(/\n+/, ' ') }.join(' | ')} |"
        end

        def render_name(object, owner = nil)
          rendered_name = "`#{object[:name]}`"
          rendered_name += ' **{warning-solid}**' if object[:is_deprecated]

          return rendered_name unless owner

          owner = Array.wrap(owner).join('')
          id = (owner + object[:name]).downcase

          %(<a id="#{id}"></a>) + rendered_name
        end

        # Returns the object description. If the object has been deprecated,
        # the deprecation reason will be returned in place of the description.
        def render_description(object, owner = nil, context = :block)
          owner = Array.wrap(owner)
          return render_deprecation(object, owner, context) if object[:is_deprecated]
          return if object[:description].blank?

          desc = object[:description].strip
          desc += '.' unless desc.ends_with?('.')
          see = doc_reference(object, owner)
          desc += " #{see}" if see
          desc += " (see [Connections](#connections))" if connection?(object)
          desc
        end

        def doc_reference(object, owner)
          field = schema_field(owner, object[:name])
          return unless field

          ref = field.try(:doc_reference)
          return if ref.blank?

          parts = ref.to_a.map do |(title, url)|
            "[#{title.strip}](#{url.strip})"
          end

          "See #{parts.join(', ')}."
        end

        def render_deprecation(object, owner, context)
          deprecation = schema_deprecation(owner, object[:name])

          unless deprecation
            reason = object[:deprecation_reason] || 'Use of this is deprecated.'
            return "**Deprecated:** #{reason}"
          end

          repl = deprecation[:replacement]
          parts = [
            "**Deprecated** in #{deprecation[:milestone]}.",
            deprecation[:reason_text],
            repl && "Use: [`#{repl}`](##{repl.downcase.tr('.', '')})."
          ].compact

          case context
          when :block
            ['WARNING:', *parts].join("\n")
          when :inline
            parts.join(' ')
          end
        end

        def schema_deprecation(type_name, field_name)
          schema_field(type_name, field_name)&.deprecation
        end

        def schema_field(type_name, field_name)
          type_name = Array.wrap(type_name)
          if type_name.size == 2
            arg_name = field_name
            type_name, field_name = type_name
          else
            type_name = type_name.first
            arg_name = nil
          end

          return if type_name.nil? || field_name.nil?

          type = schema.types[type_name]
          return unless type && type.kind.fields?

          field = type.fields[field_name]
          return field if arg_name.nil?

          args = field.arguments
          is_mutation = field.mutation && field.mutation <= ::Mutations::BaseMutation
          args = args['input'].type.unwrap.arguments if is_mutation

          args[arg_name]
        end

        def render_field_type(type)
          "[`#{type[:info]}`](##{type[:name].downcase})"
        end

        def render_return_type(query)
          return unless query[:type]

          "Returns #{render_field_type(query[:type])}."
        end

        def render_input_type(query)
          input_field = query[:input_fields]&.first
          return unless input_field

          "Input type: `#{input_field[:type][:name]}`."
        end

        # We are ignoring connections and built in types for now,
        # they should be added when queries are generated.
        def objects
          object_types = graphql_object_types.select do |object_type|
            !object_type[:name]["__"]
          end

          object_types.each do |type|
            type[:fields] += type[:connections]
          end
        end

        def interfaces
          graphql_interface_types.map { |t| t.merge(fields: t[:fields] + t[:connections]) }
        end

        def queries
          operation_fields('Query')
        end

        def mutations
          graphql_mutation_types.map do |t|
            input_type_name = t[:input_fields].first[:type][:name]
            input_type = graphql_input_object_types.find { |t| t[:name] == input_type_name }
            arguments = input_type ? input_type[:input_fields] : t[:input_fields]
            seen_type(input_type_name)
            t.merge(arguments: arguments, fields: t[:return_fields])
          end
        end

        def input_types
          graphql_input_object_types.reject { |t| seen?(t[:name]) }
        end

        def operation_fields(name)
          graphql_operation_types.find { |type| type[:name] == name }.to_h.values_at(:fields, :connections).flatten
        end

        # We ignore the built-in enum types.
        def enums
          graphql_enum_types.select do |enum_type|
            !enum_type[:name].in?(%w[__DirectiveLocation __TypeKind])
          end
        end
      end
    end
  end
end
